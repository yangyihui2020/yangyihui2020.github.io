<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于ragas和evalscope实现rag快速评测</title>
    <link href="/2025/04/07/ReadingNotes/rag/rag_eval/"/>
    <url>/2025/04/07/ReadingNotes/rag/rag_eval/</url>
    
    <content type="html"><![CDATA[<p>以下是重新组织后的语言，并使用了 Markdown 格式：</p><hr><h3 id="Ragas-评估工具概述"><a href="#Ragas-评估工具概述" class="headerlink" title="Ragas 评估工具概述"></a>Ragas 评估工具概述</h3><p>Ragas 是一个用于评估 RAG（Retrieval-Augmented Generation，检索增强生成）应用程序的工具库。它通过提供一系列工具来帮助用户轻松且自信地评估其 RAG 应用程序的性能。</p><p>Ragas 采用了一种新颖的评测数据生成方法。理想的评测数据集应该涵盖实际应用中遇到的各种类型的问题，包括不同难度等级的问题。然而，默认情况下，大语言模型（LLMs）通常不擅长创建多样化的样本，因为它们往往会遵循常见的路径。受到 Evol-Instruct 等工作的启发，Ragas 通过采用进化生成范式来实现这一目标。在这个过程中，具有不同特征的问题（如推理、条件、多个上下文等）会根据提供的文档集被系统地构建。这种方法确保了对管道中各个组件性能的全面覆盖，从而使评测过程更加稳健。</p><p>Ragas 的官网 <a href="https://docs.ragas.io/">https://docs.ragas.io/</a> 介绍了如何通过大模型 API 接口初始化评测端模型，以实现评测指标的计算。然而，这种方式可能会受到网络连接等因素的影响，从而限制本地应用的效果。</p><h3 id="在本地部署-Ragas-服务"><a href="#在本地部署-Ragas-服务" class="headerlink" title="在本地部署 Ragas 服务"></a>在本地部署 Ragas 服务</h3><p>为了克服网络连接问题并提升本地应用的性能，可以通过 <a href="https://evalscope.readthedocs.io/zh-cn/latest/user_guides/backend/rageval_backend/ragas.html">EvalScope</a> 项目结合 <a href="https://vllm.hyper.ai/docs/getting-started/quickstart/">vLLM</a> 来实现本地部署。</p><h4 id="使用-vLLM-构建本地-API-服务器"><a href="#使用-vLLM-构建本地-API-服务器" class="headerlink" title="使用 vLLM 构建本地 API 服务器"></a>使用 vLLM 构建本地 API 服务器</h4><p>vLLM 是一个高性能的推理引擎，可以在本地为大语言模型构建 API 服务器。通过 vLLM，用户可以快速部署本地 Ragas 服务，从而避免网络连接问题对评估过程的影响。</p><p>以下是使用 vLLM 构建本地 API 服务器的步骤：</p><ol><li><p><strong>安装 vLLM</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install vllm<br></code></pre></td></tr></table></figure></li><li><p><strong>启动 vLLM 服务器</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vllm serve facebook/opt-125m<br></code></pre></td></tr></table></figure><p>默认情况下，服务器会在 <code>http://localhost:8000</code> 启动。可以通过 <code>--host</code> 和 <code>--port</code> 参数指定其他地址。</p></li><li><p><strong>使用 OpenAI API 兼容模式</strong>：<br>vLLM 服务器支持 OpenAI API 协议，可以直接替代 OpenAI API。可以使用 <code>curl</code> 或 Python 客户端进行查询。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://localhost:8000/v1/completions \<br>    -H <span class="hljs-string">&quot;Content-Type: application/json&quot;</span> \<br>    -d <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">        &quot;model&quot;: &quot;facebook/opt-125m&quot;,</span><br><span class="hljs-string">        &quot;prompt&quot;: &quot;San Francisco is a&quot;,</span><br><span class="hljs-string">        &quot;max_tokens&quot;: 7,</span><br><span class="hljs-string">        &quot;temperature&quot;: 0</span><br><span class="hljs-string">    &#125;&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>在 EvalScope 中使用本地 vLLM 服务</strong>：<br>在 EvalScope 的配置中，将评测模型的 API 基础地址设置为本地 vLLM 服务器的地址。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python">eval_task_cfg = &#123;<br>    <span class="hljs-string">&quot;eval_backend&quot;</span>: <span class="hljs-string">&quot;RAGEval&quot;</span>,<br>    <span class="hljs-string">&quot;eval_config&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;tool&quot;</span>: <span class="hljs-string">&quot;RAGAS&quot;</span>,<br>        <span class="hljs-string">&quot;eval&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;testset_file&quot;</span>: <span class="hljs-string">&quot;outputs/testset_with_answer.json&quot;</span>,<br>            <span class="hljs-string">&quot;critic_llm&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;model_name&quot;</span>: <span class="hljs-string">&quot;facebook/opt-125m&quot;</span>,<br>                <span class="hljs-string">&quot;api_base&quot;</span>: <span class="hljs-string">&quot;http://localhost:8000/v1&quot;</span>,<br>                <span class="hljs-string">&quot;api_key&quot;</span>: <span class="hljs-string">&quot;EMPTY&quot;</span>,<br>            &#125;,<br>            <span class="hljs-string">&quot;embeddings&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;model_name_or_path&quot;</span>: <span class="hljs-string">&quot;AI-ModelScope/m3e-base&quot;</span>,<br>            &#125;,<br>            <span class="hljs-string">&quot;metrics&quot;</span>: [<br>                <span class="hljs-string">&quot;Faithfulness&quot;</span>,<br>                <span class="hljs-string">&quot;AnswerRelevancy&quot;</span>,<br>                <span class="hljs-string">&quot;ContextPrecision&quot;</span>,<br>                <span class="hljs-string">&quot;AnswerCorrectness&quot;</span>,<br>            ],<br>            <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;chinese&quot;</span><br>        &#125;,<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>ReadingNotes</category>
      
      <category>rag</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>M3-Embedding Multi-Linguality, Multi-Functionality, Multi-Granularity Text Embeddings Through Self-Knowledge Distillation</title>
    <link href="/2025/03/13/ReadingNotes/rag/M3-Embedding/"/>
    <url>/2025/03/13/ReadingNotes/rag/M3-Embedding/</url>
    
    <content type="html"><![CDATA[<h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>这篇文章要解决的问题是如何设计一种多语言、多功能、多粒度的文本嵌入模型，以支持超过100种工作语言的语义检索，并能同时完成<mark>密集检索、多向量检索和稀疏检索</mark>等多种检索功能。</p><h2 id="研究方法"><a href="#研究方法" class="headerlink" title="研究方法"></a>研究方法</h2><h3 id="混合检索"><a href="#混合检索" class="headerlink" title="混合检索"></a>混合检索</h3><p>M3-Embedding统一了文本嵌入模型的常见检索功能，包括密集检索、词汇（稀疏）检索和多向量检索。这些功能不仅可以单独工作，还可以协同工作以获得更强的检索质量。</p><h4 id="密集检索（Dense-retrieval-）"><a href="#密集检索（Dense-retrieval-）" class="headerlink" title="密集检索（Dense retrieval.）"></a>密集检索（Dense retrieval.）</h4><ul><li><p>输入query $q$ 将转换为基于文本编码器的隐藏状态 $\mathbf{H_q}$。使用特殊标记 “[CLS]” 的规范化隐藏状态来表示query：$e_q &#x3D; \text{norm}(\mathbf{H_q}[0])$</p></li><li><p>passage的嵌入 $p$ 为 $e_p &#x3D; \text{norm}(\mathbf{H_p}[0])$。</p></li><li><p>因此，query和passage之间的相关性分数由两个嵌入和 $e_q e_p$：$s_{\text{dense}} \leftarrow \langle e_p, e_q \rangle$ 之间的内积来衡量。</p></li></ul><h4 id="词汇检索（Lexical-Retrieval-）"><a href="#词汇检索（Lexical-Retrieval-）" class="headerlink" title="词汇检索（Lexical Retrieval. ）"></a>词汇检索（Lexical Retrieval. ）</h4><ul><li>对于query中的每个token $t$，其权重的计算公式为<br>$$<br>w_{q_t} \leftarrow\text{Relu}(\mathbf{W}_{\text{lex}}^T \mathbf{H_q}[i])<br>$$</li><li>其中 $\mathbf{W}_{\text{lex}} \in \mathbb{R}^{d \times 1}$ 是将隐藏状态映射到浮点数的矩阵。</li><li>如果某个token $t$ 在query中多次出现，只保留其最大权重。并使用相同的方法来计算passage中每个token的权重。</li><li>因此query和passage之间的相关性分数是通过query和passage中共存token（表示为 $q \cap p$）的联合重要性来计算的：<br>$$<br>s_{\text{lex}} \leftarrow \sum_{t \in q \cap p}(w_{q_t} * w_{p_t})<br>$$</li></ul><h4 id="多向量检索-Multi-Vector-Retrieval"><a href="#多向量检索-Multi-Vector-Retrieval" class="headerlink" title="多向量检索 (Multi-Vector Retrieval. )"></a>多向量检索 (Multi-Vector Retrieval. )</h4><ul><li>作为密集检索的扩展，多向量检索利用整个输出嵌入来表示query和passage：</li></ul><p>$$<br>E_q &#x3D; \text{norm}(\mathbf{W}_{\text{mul}}^T \mathbf{H_q})<br>$$</p><p>$$<br>E_p &#x3D; \text{norm}(\mathbf{W}_{\text{mul}}^T \mathbf{H_p})<br>$$    </p><ul><li><p>其中 $\mathbf{W}_{\text{mul}} \in \mathbb{R}^{d \times d}$ 是可学习的投影矩阵。</p></li><li><p>使用后期交互来计算细粒度的相关性分数：<br>$$<br>s_{\text{mul}} \leftarrow \frac{1}{N} \sum_{i&#x3D;1}^N \max_{j&#x3D;1}^M E_q[i] \cdot E_p^T[j]<br>$$</p></li><li><p>$N$ 和 $M$ 是query和passage的长度。</p></li></ul><p>每种方法都可以单独检索候选结果（多向量方法由于成本高，可以免于此步骤）。然后，根据集成的相关性分数对最终检索结果进行重新排名：</p><p>$$<br>S_{\text{rank}} \leftarrow w_1 \cdot S_{\text{dense}} + w_2 \cdot S_{\text{lex}} + w_3 \cdot S_{\text{mul}}<br>$$</p><h3 id="自我认识蒸馏-Self-Knowledge-Distillation"><a href="#自我认识蒸馏-Self-Knowledge-Distillation" class="headerlink" title="自我认识蒸馏(Self-Knowledge Distillation)"></a>自我认识蒸馏(Self-Knowledge Distillation)</h3><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>嵌入模型经过训练以区分阳性样本和阴性样本。对于每种检索方法，与负样本相比，应为查询的正样本分配更高的分数。因此，进行训练过程以最小化 InfoNCE 损失，其一般形式由以下损失函数表示：</p><p>$$<br>\mathcal{L}<em>{s(\cdot)} &#x3D; -\log \frac{\exp(s(q, p^*) &#x2F; \tau)} {\sum</em>{p \in {p^*, p’}} \exp(s(q, p) &#x2F; \tau)}<br>$$</p><p>这里，$p^*$ 和 $p’$ 代表查询 $q$ 的正样本和负样本；$s(\cdot)$ 是 ${s_{\text{dense}}(\cdot)$，$s_{\text{lex}}(\cdot)$，$s_{\text{mul}}(\cdot)$ 中的任何函数。</p><p>Self-Knowledge Distillation中提出的损失函数如下：</p><ul><li>不同检索方法的训练目标可能与各自的方法相互冲突。因此，原生多目标训练可能不利于嵌入的质量。为了促进多个检索函数的优化，作者建议在自我知识蒸馏之上统一训练过程。在最简单的形式中，积分可以是不同预测分数的加权和：</li></ul><p>$$<br>S_{\text{inter}} \leftarrow w_1 \cdot S_{\text{dense}} + w_2 \cdot S_{\text{lex}} + w_3 \cdot S_{\text{mul}}.<br>$$</p><ul><li>使用积分分数 $S_{inter}$作为老师，于是其中每种检索方法的损失函数被修改为:</li></ul><p>$$<br>\mathcal{L}^{‘}<em>* \leftarrow -p(s</em>{\text{inter}}) \ast \log p(s_*).<br>$$</p><ul><li>这里，$p(\cdot)$ 是 softmax 激活；$s_*$ 是 $s_{\text{dense}}$、$s_{\text{lex}}$ 和 $s_{\text{mul}}$ 中的任何成员。我们进一步整合并归一化修改后的损失函数：<br>$$<br>\mathcal{L}’ \leftarrow \left( \lambda_1 \cdot \mathcal{L}’<em>{\text{dense}} + \lambda_2 \cdot \mathcal{L}’</em>{\text{lex}} + \lambda_3 \cdot \mathcal{L}’_{\text{mul}} \right) &#x2F; 3.<br>$$</li></ul><p>最后，用 $\mathcal{L}$ 和的 $\mathcal{L}’$ 线性组合推导出自我知识蒸馏的最终损失函数：$\mathcal{L}_{\text{final}} \leftarrow \left( \mathcal{L} + \mathcal{L}’ \right) &#x2F; 2$。</p><h4 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h4><p>训练过程包括一个<strong>多阶段工作流</strong>（如图所示）。首先，文本编码器（XLM-RoBERTa模型）使用大量无监督数据进行预训练，其中仅以基本形式的对比学习训练密集检索。</p><p>在第二阶段应用自知识蒸馏，其中嵌入模型被微调以建立三个检索功能。$\mathbf{W}<em>{\text{lex}}$的随机初始化导致$s</em>{\text{lex}}$准确性差和训练开始时的$\mathcal{L}_{\text{lex}}$高。</p><p><img src="/.io//image.png" alt="alt text"></p>]]></content>
    
    
    <categories>
      
      <category>ReadingNotes</category>
      
      <category>rag</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/02/25/hello-world/"/>
    <url>/2025/02/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo搭建博客实现多端同步</title>
    <link href="/2025/02/25/essays/Hexo/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%AD%A5/"/>
    <url>/2025/02/25/essays/Hexo/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="基于hexo-github实现博客撰写的多端同步功能"><a href="#基于hexo-github实现博客撰写的多端同步功能" class="headerlink" title="基于hexo+github实现博客撰写的多端同步功能"></a>基于hexo+github实现博客撰写的多端同步功能</h1><p>hexo 本身自带的同步功能<code>hexo d</code>上传的只是网页部署文件，未上传网页源文件，所以如果我们要在另一台设备上对博客进行修改的话就会遇到困难。我们可以在在github的blog仓库新建一个分支，存储源文件，然后在不同设备间同步源文件。这样就可以实现博客在不同设备上的同步了。</p><h2 id="github对应的仓库新建分支"><a href="#github对应的仓库新建分支" class="headerlink" title="github对应的仓库新建分支"></a>github对应的仓库新建分支</h2><p>首先你需要在你博客对应的github仓库(比如我的就是<code>https://github.com/yangyihui2020/yangyihui2020.github.io)</code>新建分支<code>hexo</code>。</p><h2 id="在已有博客文件的旧设备上执行的操作-："><a href="#在已有博客文件的旧设备上执行的操作-：" class="headerlink" title="在已有博客文件的旧设备上执行的操作 ："></a>在已有博客文件的旧设备上执行的操作 ：</h2><p>然后在本地任意目录下执行 <code>git clone</code>。并切换到对应分支：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git clone git@github<span class="hljs-selector-class">.com</span>:yangyihui2020/yangyihui2020<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.git</span><br>cd yangyihui2020<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span><br>git <span class="hljs-selector-tag">switch</span> hexo<br></code></pre></td></tr></table></figure><p>然后删除掉仓库目录（比如我的就是<code>yangyihui2020.github.io</code>)下除去.git之外的所有文件，并将原博客目录下的所有文件复制到该目录下。</p><p>然后上传到hexo分支</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> .<br><span class="hljs-symbol">git</span> commit -m <span class="hljs-string">&quot;新建hexo分支&quot;</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> <br></code></pre></td></tr></table></figure><h2 id="在新设备上执行的操作-："><a href="#在新设备上执行的操作-：" class="headerlink" title="在新设备上执行的操作 ："></a>在新设备上执行的操作 ：</h2><p>在新设备，你需要提前配置好hexo所需要的环境。可以参考<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a> 。</p><p>然后在任意目录下新建一个目录<code>blogs</code>(这个名字随意),进入该目录执行<code>hexo init</code>。<br>然后清空该目录的文件，并执行<code>git clone</code>并切换到对应的分支:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git clone git@github<span class="hljs-selector-class">.com</span>:yangyihui2020/yangyihui2020<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.git</span><br>git <span class="hljs-selector-tag">switch</span> hexo<br></code></pre></td></tr></table></figure><p>然后你就可以在不同设备上实现hexo博客的源文件共享了。</p><div class="note note-info">            <p>注意，每次写博客之前最好执行<code>git pull</code>，上传网页后同时执行一下<code>git push</code>来保持文件的同步</p>          </div><h2 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h2><div class="note note-danger">            <p>在这个过程中可能会遇到<code>hexo g</code>等命令不起作用的情况，hexo提示的命令也变少了.</p>          </div><div class="note note-info">            <p>这个时候你就要观察你执行命令的目录是否是你博客真正对应的目录。<br>比如我执行完上述操作后，我的博客目录应该是yangyihui2020.github.io，而不是blogs。<br>你必须要在博客对应目录下执行对应操作才行。 </p>          </div>]]></content>
    
    
    <categories>
      
      <category>essays</category>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks</title>
    <link href="/2025/02/24/ReadingNotes/rag/Retrieval-Augmented%20Generation%20for%20%20Knowledge-Intensive%20NLP%20Tasks/"/>
    <url>/2025/02/24/ReadingNotes/rag/Retrieval-Augmented%20Generation%20for%20%20Knowledge-Intensive%20NLP%20Tasks/</url>
    
    <content type="html"><![CDATA[<h1 id="RAG-检索增强生成技术背景介绍"><a href="#RAG-检索增强生成技术背景介绍" class="headerlink" title="RAG 检索增强生成技术背景介绍"></a>RAG 检索增强生成技术背景介绍</h1><p>RAG（Retrieval-Augmented Generation，检索增强生成） 是一种结合了信息检索技术与语言生成模型的人工智能技术。该技术通过从外部知识库中检索相关信息，并将其作为提示（Prompt）输入给大型语言模型（LLMs），以增强模型处理知识密集型任务的能力，如问答、文本摘要、内容生成等。RAG模型由Facebook AI Research（FAIR）团队于2020年首次提出，并迅速成为大模型应用中的热门方案。(这篇论文可以说是RAG技术的开山之作)</p><p><img src="/images/rag.jpg"></p><p>RAG一般有3个步骤：</p><ol><li><p>检索：检索是RAG流程的第一步，从预先建立的知识库中检索与问题相关的信息。这一步的目的是为后续的生成过程提供有用的上下文信息和知识支撑。</p></li><li><p>增强：RAG中增强是将检索到的信息用作生成模型（即大语言模型）的上下文输入，以增强模型对特定问题的理解和回答能力。这一步的目的是将外部知识融入生成过程中，使生成的文本内容更加丰富、准确和符合用户需求。通过增强步骤，LLM模型能够充分利用外部知识库中的信息。</p></li><li><p>生成：生成是RAG流程的最后一步。这一步的目的是结合LLM生成符合用户需求的回答。生成器会利用检索到的信息作为上下文输入，并结合大语言模型来生成文本内容。</p></li></ol><h1 id="RAG-Retrieval-Augmented-Generation-for-Knowledge-Intensive-NLP-Tasks"><a href="#RAG-Retrieval-Augmented-Generation-for-Knowledge-Intensive-NLP-Tasks" class="headerlink" title="RAG Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks"></a>RAG Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks</h1><p><a href="https://arxiv.org/abs/2005.11401">文章链接</a></p><h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>这篇文章的研究背景是大型预训练语言模型虽然能够在下游NLP任务中存储事实性知识并取得优异表现，但在访问和精确操作知识方面仍然有限。因此，在知识密集型任务中，这些模型的表现落后于特定任务的架构。此外，提供决策的可追溯性和更新世界知识仍然是开放的研究问题。</p><p>文章着眼于此，提出的RAG模型通过结合预训练的参数化记忆和非参数化记忆，在知识密集型NLP任务中取得了显著的性能提升。</p><h2 id="研究方法"><a href="#研究方法" class="headerlink" title="研究方法"></a>研究方法</h2><p>这篇论文提出了两种RAG模型：RAG-Sequence和RAG-Token，用于解决知识密集型任务中的生成问题：</p><ol><li>​**RAG-Sequence模型:**​ 该模型使用相同的检索文档来生成整个序列。它将检索到的文档视为一个单一的潜在变量，并通过top-K近似来边缘化以获得seq2seq概率。<br><img src="/images/RAG-Sequence-Model.png" alt="RAG-Sequence-Model相应公式"></li><li>​**RAG-Token模型:**​ 该模型为每个目标标记抽取不同的潜在文档，并相应地进行边缘化。这允许生成器在生成答案时从多个文档中选择内容。具体来说，使用检索器检索前 K 个文档，然后生成器为每个文档的下一个输出标记生成一个分布，然后边缘化，并使用以下输出标记重复该过程。<br><img src="/images/RAG-Token-Model.png" alt="alt text"></li></ol><p>检索器：使用DPR（Dense Passage Retriever）作为检索组件，采用双向编码器架构，通过最大内积搜索（MIPS）问题近似求解top-K文档。<br><img src="/images/Retriever.png" alt="alt text"><br>生成器：使用BART-large作为生成器组件，通过连接输入和检索内容来生成输出。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>实验采用了多个知识密集型NLP任务的数据集，包括自然问题（NQ）、TriviaQA（TQA）、WebQuestions（WQ）、CuratedTrec（CT）、MS-MARCO、Jeopardy问题生成和FEVER。</p>]]></content>
    
    
    <categories>
      
      <category>ReadingNotes</category>
      
      <category>rag</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>THE power of noise</title>
    <link href="/2025/02/24/ReadingNotes/rag/The%20Power%20of%20Noise-Redefining%20Retrieval%20for%20RAG%20Systems/"/>
    <url>/2025/02/24/ReadingNotes/rag/The%20Power%20of%20Noise-Redefining%20Retrieval%20for%20RAG%20Systems/</url>
    
    <content type="html"><![CDATA[<p>ddgf</p>]]></content>
    
    
    <categories>
      
      <category>ReadingNotes</category>
      
      <category>rag</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>用hexo+fluid配置个人博客</title>
    <link href="/2025/02/22/essays/Hexo/%E7%94%A8hexo+fluid%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2025/02/22/essays/Hexo/%E7%94%A8hexo+fluid%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p> 在开始之前，你需要先参考<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a>进行安装、建站。</p><h2 id="然后设置你的主题为fluid："><a href="#然后设置你的主题为fluid：" class="headerlink" title="然后设置你的主题为fluid："></a>然后设置你的主题为fluid：</h2><ul><li><p>进入博客目录执行命令：<code>npm install --save hexo-theme-fluid</code></p></li><li><p>修改 Hexo 博客目录下<code>_config.yml</code>中的对应参数：</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题为fluid</span><br></code></pre></td></tr></table></figure><h1 id="开始新文档创建"><a href="#开始新文档创建" class="headerlink" title="开始新文档创建"></a>开始新文档创建</h1><h2 id="创建关于页"><a href="#创建关于页" class="headerlink" title="创建关于页"></a>创建<code>关于页</code></h2><ul><li><p>在博客目录下执行命令：<code>hexo new page about</code></p></li><li><p>创建成功后修改 <code>/source/about/index.md</code>，在其中添加 <code>layout</code> 属性。</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">标题</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里写关于页的正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>根据官方文档，<code>layout: about</code> 必须存在，并且不能修改成其他值，否则不会显示头像等样式。</p><p>一般<code>关于页</code>可以介绍你的个人资料</p>          </div><h2 id="创建新的文章并为其归类。（这里的做法为个人偏好，仅供参考）"><a href="#创建新的文章并为其归类。（这里的做法为个人偏好，仅供参考）" class="headerlink" title="创建新的文章并为其归类。（这里的做法为个人偏好，仅供参考）"></a>创建新的文章并为其归类。（这里的做法为个人偏好，仅供参考）</h2><p>我现在需要写一篇名为<code>用hexo+fluid配置个人博客</code>的文章，我想给其分类到<code>随笔</code>下的<code>Hexo</code>小类中，这里我就用到了hexo的二级导航功能。具体做法如下：</p><h3 id="生成“分类”页并添加tpye属性"><a href="#生成“分类”页并添加tpye属性" class="headerlink" title="生成“分类”页并添加tpye属性"></a>生成“分类”页并添加tpye属性</h3><ul><li><p>进入博客所在文件夹。执行命令：<code>hexo new page categories</code></p></li><li><p>修改博客目录下的<code>source/categories/index.md</code>为：</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">categories</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2025-02-22 19:55:44</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">categories</span> <span class="hljs-comment">#添加这一行代码到原md文件中</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><h3 id="创建随笔-Hexo类别："><a href="#创建随笔-Hexo类别：" class="headerlink" title="创建随笔\Hexo类别："></a>创建<code>随笔\Hexo</code>类别：</h3><ul><li><p>在 <code>source/categories</code> 文件夹下创建一个名为 <code>essay</code> 的文件夹,再在<code>essay</code>文件夹内新建<code>Hexo</code>文件夹</p></li><li><p>在<code>source/categories/essay/和</code> <code>source/categories/essay/Hexo</code> 文件夹下均创建一个名为 <code>index.md</code> 的文件，内容如下</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2025-02-22 19:57:44</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">categories</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><ul><li>修改主题目录下的<code>_config.yaml</code>文件中的menu属性，它将影响到网页中的菜单栏，修改为：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">menu:</span><br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;home&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-home-fill&quot;</span> &#125;<br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;随笔&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/categories/essay/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont book icon-book&quot;</span>,<br>    <span class="hljs-attr">submenu:</span> [&#123;<span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;Hexo用户笔记&#x27;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/categories/essay/Hexo/&#x27;</span>&#125;,],&#125;<br>  <span class="hljs-comment"># 设置你的多级目录以及设置key的值作为菜单栏中展示的分类名</span><br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;about&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/about/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-user-fill&quot;</span>,&#125;<br>  <span class="hljs-comment">#- &#123; key: &quot;archive&quot;, link: &quot;/archives/&quot;, icon: &quot;iconfont icon-archive-fill&quot; &#125;</span><br>  <span class="hljs-comment">#- &#123; key: &quot;categories&quot;, link: &quot;/categories/&quot;, icon: &quot;iconfont icon-category-fill&quot;, &#125;</span><br>  <span class="hljs-comment">#- &#123; key: &quot;tag&quot;, link: &quot;/tags/&quot;, icon: &quot;iconfont icon-tags-fill&quot; &#125;</span><br>  <span class="hljs-comment">#- &#123; key: &quot;links&quot;, link: &quot;/links/&quot;, icon: &quot;iconfont icon-link-fill&quot; &#125;</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>注意，我这里注释掉了不必要的菜单栏</p>          </div><h3 id="创建新的文章并归类"><a href="#创建新的文章并归类" class="headerlink" title="创建新的文章并归类:"></a>创建新的文章并归类:</h3><ul><li><p>在<code>source\_posts</code>目录下新建<code>essays\Hexo</code>目录结构</p></li><li><p>执行<code>hexo new 用hexo+fluid配置个人博客 -p essays\Hexo\用hexo+fluid配置个人博客</code></p></li><li><p>修改<code>source\_posts\essays\Hexo\用hexo+fluid配置个人博客.md</code>中的内容为：</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">用hexo+fluid配置个人博客</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2025-02-23 14:36:55</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-attr">categories:</span> [<span class="hljs-string">essay</span>,<span class="hljs-string">Hexo</span>] <span class="hljs-comment">#加上这一栏即可</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>  执行完上述一系列操作之后，你将得到这样一个界面：</p><p>  <img src="/images/image-20250223144908444.jpg"></p><p>  然后你就可以编辑<code>用hexo+fluid配置个人博客.md</code>中的内容作为你的第一篇博客了。</p>]]></content>
    
    
    <categories>
      
      <category>essays</category>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
